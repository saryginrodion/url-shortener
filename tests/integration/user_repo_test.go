package integration

import (
	"context"
	"testing"
	"time"

	"github.com/google/uuid"
	"roadmap.restapi/internal/user"
)

func TestUserRepository_Create_Success(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	email := "create@test.com"
	password := "password123"
	passwordHash := hasher.Hash(password)

	u := &user.User{
		Email:        email,
		PasswordHash: passwordHash,
	}

	if err := repo.Create(ctx, u); err != nil {
		t.Fatalf("failed to create user: %v", err)
	}

	if u.ID == uuid.Nil {
		t.Error("ID should be generated by DB")
	}
	if u.Email != email {
		t.Errorf("email mismatch: got %s, want %s", u.Email, email)
	}
	if time.Since(u.CreatedAt) > time.Second {
		t.Errorf("CreatedAt is too old: %v", u.CreatedAt)
	}
	if !hasher.Check(password, u.PasswordHash) {
		t.Error("stored password hash doesn't match")
	}
}

func TestUserRepository_Create_DuplicateEmail(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	email := "duplicate@test.com"

	u1 := &user.User{Email: email, PasswordHash: hasher.Hash("pwd1")}
	if err := repo.Create(ctx, u1); err != nil {
		t.Fatalf("setup failed: %v", err)
	}

	u2 := &user.User{Email: email, PasswordHash: hasher.Hash("pwd2")}
	err := repo.Create(ctx, u2)
	if err == nil {
		t.Fatal("expected error on duplicate email, got nil")
	}
	if err != user.ErrUserAlreadyExists {
		t.Errorf("wrong error: got %v, want %v", err, user.ErrUserAlreadyExists)
	}
}

func TestUserRepository_ByID_Success(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	u := &user.User{Email: "byid@test.com", PasswordHash: hasher.Hash("pwd")}
	if err := repo.Create(ctx, u); err != nil {
		t.Fatalf("setup failed: %v", err)
	}

	found, err := repo.ByID(ctx, u.ID)
	if err != nil {
		t.Fatalf("failed to get by id: %v", err)
	}
	if found.ID != u.ID {
		t.Errorf("ID mismatch: got %s, want %s", found.ID, u.ID)
	}
	if found.Email != u.Email {
		t.Errorf("email mismatch: got %s, want %s", found.Email, u.Email)
	}
}

func TestUserRepository_ByID_NotFound(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	_, err := repo.ByID(ctx, uuid.New())
	if err == nil {
		t.Fatal("expected ErrUserNotFound, got nil")
	}
	if err != user.ErrUserNotFound {
		t.Errorf("wrong error: got %v, want %v", err, user.ErrUserNotFound)
	}
}

func TestUserRepository_ByEmail_Success(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	email := "byemail@test.com"
	u := &user.User{Email: email, PasswordHash: hasher.Hash("pwd")}
	if err := repo.Create(ctx, u); err != nil {
		t.Fatalf("setup failed: %v", err)
	}

	found, err := repo.ByEmail(ctx, email)
	if err != nil {
		t.Fatalf("failed to get by email: %v", err)
	}
	if found.Email != email {
		t.Errorf("email mismatch: got %s, want %s", found.Email, email)
	}
}

func TestUserRepository_ByEmail_NotFound(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	_, err := repo.ByEmail(ctx, "nonexistent@test.com")
	if err == nil {
		t.Fatal("expected ErrUserNotFound, got nil")
	}
	if err != user.ErrUserNotFound {
		t.Errorf("wrong error: got %v, want %v", err, user.ErrUserNotFound)
	}
}

func TestUserRepository_Update_Success(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	u := &user.User{Email: "update@test.com", PasswordHash: hasher.Hash("oldpwd")}
	if err := repo.Create(ctx, u); err != nil {
		t.Fatalf("setup failed: %v", err)
	}

	newEmail := "updated@test.com"
	newPassword := "newpassword"
	u.Email = newEmail
	u.PasswordHash = hasher.Hash(newPassword)

	if err := repo.Update(ctx, u); err != nil {
		t.Fatalf("failed to update: %v", err)
	}

	updated, err := repo.ByID(ctx, u.ID)
	if err != nil {
		t.Fatalf("failed to reload: %v", err)
	}
	if updated.Email != newEmail {
		t.Errorf("email not updated: got %s, want %s", updated.Email, newEmail)
	}
	if !hasher.Check(newPassword, updated.PasswordHash) {
		t.Error("password hash not updated")
	}
}

func TestUserRepository_Update_NotFound(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	u := &user.User{
		ID:           uuid.New(),
		Email:        "ghost@test.com",
		PasswordHash: hasher.Hash("pwd"),
	}

	err := repo.Update(ctx, u)
	if err == nil {
		t.Fatal("expected error on update non-existent user, got nil")
	}
	if err != user.ErrUserNotFound {
		t.Errorf("wrong error: got %v, want %v", err, user.ErrUserNotFound)
	}
}

func TestUserRepository_Delete_Success(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	hasher := user.NewArgon2IDPasswordHasher()
	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	u := &user.User{Email: "delete@test.com", PasswordHash: hasher.Hash("pwd")}
	if err := repo.Create(ctx, u); err != nil {
		t.Fatalf("setup failed: %v", err)
	}

	if err := repo.Delete(ctx, u.ID); err != nil {
		t.Fatalf("failed to delete: %v", err)
	}

	_, err := repo.ByID(ctx, u.ID)
	if err != user.ErrUserNotFound {
		t.Errorf("expected ErrUserNotFound after delete, got %v", err)
	}
}

func TestUserRepository_Delete_NotFound(t *testing.T) {
	db := PostgresConnection(t)
	defer CleanTables(t, db, []string{"users"})

	repo := user.NewPostgresUserRepository(db)
	ctx := context.Background()

	err := repo.Delete(ctx, uuid.New())
	if err != user.ErrUserNotFound {
		t.Errorf("expected ErrUserNotFound on delete non-existent, got %v", err)
	}
}
